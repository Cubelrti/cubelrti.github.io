<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Promise Optimization | Cubelrti&#39;s Blog</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.854efcde.css" as="style"><link rel="preload" href="/assets/js/app.f42c0b44.js" as="script"><link rel="preload" href="/assets/js/31.bc58c029.js" as="script"><link rel="prefetch" href="/assets/js/10.516d8242.js"><link rel="prefetch" href="/assets/js/11.c36dcbcb.js"><link rel="prefetch" href="/assets/js/12.e895b184.js"><link rel="prefetch" href="/assets/js/13.ec7be9a7.js"><link rel="prefetch" href="/assets/js/14.54d29f87.js"><link rel="prefetch" href="/assets/js/15.e407cc44.js"><link rel="prefetch" href="/assets/js/16.db49905b.js"><link rel="prefetch" href="/assets/js/17.736569b1.js"><link rel="prefetch" href="/assets/js/18.1a4266aa.js"><link rel="prefetch" href="/assets/js/19.fab2abb6.js"><link rel="prefetch" href="/assets/js/2.ce88158f.js"><link rel="prefetch" href="/assets/js/20.556d670c.js"><link rel="prefetch" href="/assets/js/21.dc368674.js"><link rel="prefetch" href="/assets/js/22.5febb538.js"><link rel="prefetch" href="/assets/js/23.a8022afa.js"><link rel="prefetch" href="/assets/js/24.12852a72.js"><link rel="prefetch" href="/assets/js/25.5a2f1e7f.js"><link rel="prefetch" href="/assets/js/26.d78beae1.js"><link rel="prefetch" href="/assets/js/27.5cdcdcdf.js"><link rel="prefetch" href="/assets/js/28.4adfd5ba.js"><link rel="prefetch" href="/assets/js/29.a67dfb0b.js"><link rel="prefetch" href="/assets/js/3.2891e7af.js"><link rel="prefetch" href="/assets/js/30.52bb0b17.js"><link rel="prefetch" href="/assets/js/32.c32f2855.js"><link rel="prefetch" href="/assets/js/33.353142fa.js"><link rel="prefetch" href="/assets/js/34.37af366f.js"><link rel="prefetch" href="/assets/js/35.9bbb247e.js"><link rel="prefetch" href="/assets/js/36.dcd775a7.js"><link rel="prefetch" href="/assets/js/37.7a866a32.js"><link rel="prefetch" href="/assets/js/38.402538ca.js"><link rel="prefetch" href="/assets/js/39.536dee2f.js"><link rel="prefetch" href="/assets/js/4.079b915f.js"><link rel="prefetch" href="/assets/js/40.53a05fc2.js"><link rel="prefetch" href="/assets/js/41.e99a5f5e.js"><link rel="prefetch" href="/assets/js/42.74be2de5.js"><link rel="prefetch" href="/assets/js/43.6a321652.js"><link rel="prefetch" href="/assets/js/44.254475de.js"><link rel="prefetch" href="/assets/js/45.bea33be6.js"><link rel="prefetch" href="/assets/js/46.c1408df5.js"><link rel="prefetch" href="/assets/js/47.74ba1c55.js"><link rel="prefetch" href="/assets/js/48.91bdc6a5.js"><link rel="prefetch" href="/assets/js/49.b8e75933.js"><link rel="prefetch" href="/assets/js/5.b2c7c0bf.js"><link rel="prefetch" href="/assets/js/50.efea2307.js"><link rel="prefetch" href="/assets/js/51.174b1c37.js"><link rel="prefetch" href="/assets/js/52.fd97caa2.js"><link rel="prefetch" href="/assets/js/6.632b27cc.js"><link rel="prefetch" href="/assets/js/7.b2cab865.js"><link rel="prefetch" href="/assets/js/8.5c5f6195.js"><link rel="prefetch" href="/assets/js/9.ad4020c1.js">
    <link rel="stylesheet" href="/assets/css/0.styles.854efcde.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Cubelrti's Blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="https://cubelrti.github.io/resume/en/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Resume
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="https://cubelrti.github.io/resume/en/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Resume
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/async-iteration.html" class="sidebar-link">Async Iteration</a></li><li><a href="/bit-manupulation.html" class="sidebar-link">Bit Manupulation</a></li><li><a href="/css-framework-think.html" class="sidebar-link">CSS Framework Think</a></li><li><a href="/css-scrollbars.html" class="sidebar-link">CSS Scrollbars</a></li><li><a href="/darknet-cv2.html" class="sidebar-link">DarkNet &amp; CV2</a></li><li><a href="/event-emitter.html" class="sidebar-link">Event Emitter</a></li><li><a href="/framework-analysis.html" class="sidebar-link">Framework Analysis</a></li><li><a href="/front-end-design-pattern.html" class="sidebar-link">Front-End Design Patterns</a></li><li><a href="/front-end-interview.html" class="sidebar-link">Front-End Interview</a></li><li><a href="/hairline-css.html" class="sidebar-link">Hairline CSS</a></li><li><a href="/image-orientation.html" class="sidebar-link">Image Orientation</a></li><li><a href="/indexed-db.html" class="sidebar-link">IndexedDB Cheatsheet</a></li><li><a href="/intersection-observer.html" class="sidebar-link">Intersection Observer</a></li><li><a href="/javascript-extend.html" class="sidebar-link">Extend in Javascript</a></li><li><a href="/javascript-trending.html" class="sidebar-link">Javascript Trending</a></li><li><a href="/lambda-functions.html" class="sidebar-link">Lambda Expressions</a></li><li><a href="/lazy-load.html" class="sidebar-link">Lazy Load on Web</a></li><li><a href="/lowdb-101.html" class="sidebar-link">LowDB Code Reading</a></li><li><a href="/material-ripple.html" class="sidebar-link">Material Ripple</a></li><li><a href="/modular-javascript.html" class="sidebar-link">Modular Javascript</a></li><li><a href="/node-reverse-proxy.html" class="sidebar-link">Node Reverse Proxy</a></li><li><a href="/nodejs-data-persistence.html" class="sidebar-link">NodeJS Data Persistence</a></li><li><a href="/npm-security.html" class="sidebar-link">NPM Security</a></li><li><a href="/object-creation.html" class="sidebar-link">Object Prototype Extending</a></li><li><a href="/openapi-cheatsheet.html" class="sidebar-link">OpenAPI Cheatsheet</a></li><li><a href="/overcoming-inituition-in-programming.html" class="sidebar-link">Programming Intuition</a></li><li><a href="/pixijs-101.html" class="sidebar-link">PixiJS 101</a></li><li><a href="/promise-optimization.html" class="active sidebar-link">Promise Optimization</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/promise-optimization.html#异步编程的新方案" class="sidebar-link">异步编程的新方案</a></li><li class="sidebar-sub-header"><a href="/promise-optimization.html#async-性能优化" class="sidebar-link">async 性能优化</a></li><li class="sidebar-sub-header"><a href="/promise-optimization.html#开发体验优化" class="sidebar-link">开发体验优化</a></li><li class="sidebar-sub-header"><a href="/promise-optimization.html#结论" class="sidebar-link">结论</a></li></ul></li><li><a href="/prototype-review.html" class="sidebar-link">Prototype Review</a></li><li><a href="/python-asyncio.html" class="sidebar-link">Python asyncio</a></li><li><a href="/react-fiber.html" class="sidebar-link">React Fiber</a></li><li><a href="/redux-saga.html" class="sidebar-link">Redux Saga</a></li><li><a href="/rust-101.html" class="sidebar-link">Rust 101</a></li><li><a href="/throttle-and-debounce.html" class="sidebar-link">Throttle and Debounce</a></li><li><a href="/typescript-and-node.html" class="sidebar-link">TypeScript and Node</a></li><li><a href="/typescript-and-react.html" class="sidebar-link">Typescript and React</a></li><li><a href="/undefined-in-javascript.html" class="sidebar-link">Undefined in Javascript</a></li><li><a href="/v8-async.html" class="sidebar-link">V8 Async</a></li><li><a href="/v8-sorting.html" class="sidebar-link">V8 Sorting</a></li><li><a href="/v8-torque.html" class="sidebar-link">V8 Torque</a></li><li><a href="/variable-length-curring.html" class="sidebar-link">Variable Length Curring</a></li><li><a href="/vue-impl-01.html" class="sidebar-link">Vue Implementation 01</a></li><li><a href="/vue-impl-02.html" class="sidebar-link">Vue Implementation 02</a></li><li><a href="/vue-impl-03.html" class="sidebar-link">Vue Implementation 03</a></li><li><a href="/vuex-typescript.html" class="sidebar-link">Vuex Typescript</a></li><li><a href="/webrtc-practice.html" class="sidebar-link">WebRTC Practice</a></li><li><a href="/websocket-practice.html" class="sidebar-link">Websocket Practice</a></li><li><a href="/webworker-caveats.html" class="sidebar-link">WebWorker Caveats</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="promise-optimization"><a href="#promise-optimization" aria-hidden="true" class="header-anchor">#</a> Promise Optimization</h1> <p><img src="https://img.alicdn.com/tfs/TB1XkgupxjaK1RjSZKzXXXVwXXa-800-450.png" alt="image | left">
翻译自：<a href="https://v8.dev/blog/fast-async" target="_blank" rel="noopener noreferrer">Faster async functions and promises<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
JavaScript 的异步过程一直被认为是不够快的，更糟糕的是，在 NodeJS 等实时性要求高的场景下调试堪比噩梦。不过，这一切正在改变，这篇文章会详细解释我们是如何优化 V8 引擎（也会涉及一些其它引擎）里的 async 函数和 promises 的，以及伴随着的开发体验的优化。
<strong>温馨提示：</strong> 这里有个 <a href="https://www.youtube.com/watch?v=DFP5DKDQfOc" target="_blank" rel="noopener noreferrer">视频<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以结合着文章看。</p> <h2 id="异步编程的新方案"><a href="#异步编程的新方案" aria-hidden="true" class="header-anchor">#</a> 异步编程的新方案</h2> <h3 id="从-callbacks-到-promises，再到-async-函数"><a href="#从-callbacks-到-promises，再到-async-函数" aria-hidden="true" class="header-anchor">#</a> 从 callbacks 到 promises，再到 async 函数</h3> <p>在 promises 正式成为 JavaScript 标准的一部分之前，回调被大量用在异步编程中，下面是个例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">validateParams</span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">done</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dbQuery</span><span class="token punctuation">(</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> dbResults<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">done</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">serviceCall</span><span class="token punctuation">(</span>dbResults<span class="token punctuation">,</span> <span class="token punctuation">(</span>error<span class="token punctuation">,</span> serviceResults<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">done</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> serviceResults<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类似以上深度嵌套的回调通常被称为「回调黑洞」，因为它让代码可读性变差且不易维护。
幸运地是，现在 promises 成为了 JavaScript 语言的一部分，以下实现了跟上面同样的功能：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">validateParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>dbQuery<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>serviceCall<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最近，JavaScript 支持了 <a href="https://developers.google.com/web/fundamentals/primers/async-functions" target="_blank" rel="noopener noreferrer">async 函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，上面的异步代码可以写成像下面这样的同步的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">validateParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> dbResults <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">dbQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">serviceCall</span><span class="token punctuation">(</span>dbResults<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> results<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>借助 async 函数，代码变得更简洁，代码的逻辑和数据流都变得更可控，当然其实底层实现还是异步。（注意，JavaScript 还是单线程执行，async 函数并不会开新的线程。）</p> <h3 id="从事件监听回调到-async-迭代器"><a href="#从事件监听回调到-async-迭代器" aria-hidden="true" class="header-anchor">#</a> 从事件监听回调到 async 迭代器</h3> <p>NodeJS 里 <a href="https://nodejs.org/api/stream.html#stream_readable_streams" target="_blank" rel="noopener noreferrer">ReadableStreams<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 作为另一种形式的异步也特别常见，下面是个例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> body <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
  req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    body <span class="token operator">+=</span> chunk<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码有一点难理解：只能通过回调去拿 chunks 里的数据流，而且数据流的结束也必须在回调里处理。如果你没能理解到函数是立即结束但实际处理必须在回调里进行，可能就会引入 bug。
同样很幸运，ES2018 特性里引入的一个很酷的 <a href="http://2ality.com/2016/10/asynchronous-iteration.html" target="_blank" rel="noopener noreferrer">async 迭代器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 可以简化上面的代码：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> body <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> chunk <span class="token keyword">of</span> req<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      body <span class="token operator">+=</span> chunk<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">500</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">1337</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以把所有数据处理逻辑都放到一个 async 函数里使用 <code>for await…of</code> 去迭代 chunks，而不是分别在 <code>'data'</code> 和 <code>'end'</code> 回调里处理，而且我们还加了 <code>try-catch</code> 块来避免 <code>unhandledRejection</code> 问题。
以上这些特性你今天就可以在生成环境使用！async 函数__从 Node.js 8 (V8 v6.2 / Chrome 62) 开始就已全面支持__，async 迭代器__从 Node.js 10 (V8 v6.8 / Chrome 68) 开始支持__。</p> <h2 id="async-性能优化"><a href="#async-性能优化" aria-hidden="true" class="header-anchor">#</a> async 性能优化</h2> <p>从 V8 v5.5 (Chrome 55 &amp; Node.js 7) 到 V8 v6.8 (Chrome 68 &amp; Node.js 10)，我们致力于异步代码的性能优化，目前的效果还不错，你可以放心地使用这些新特性。
<img src="https://img.alicdn.com/tfs/TB1LLxkpxTpK1RjSZFMXXbG_VXa-600-371.svg" alt="image | left">
上面的是 <a href="https://github.com/v8/promise-performance-tests/blob/master/lib/doxbee-async.js" target="_blank" rel="noopener noreferrer">doxbee 基准测试<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，用于反应重度使用 promise 的性能，图中纵坐标表示执行时间，所以越小越好。
另一方面，<a href="https://github.com/v8/promise-performance-tests/blob/master/lib/parallel-async.js" target="_blank" rel="noopener noreferrer">parallel 基准测试<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 反应的是重度使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noopener noreferrer">Promise.all()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的性能情况，结果如下：
<img src="https://img.alicdn.com/tfs/TB1ShxdpwDqK1RjSZSyXXaxEVXa-600-371.svg" alt="image | left"> <code>Promise.all</code> 的性能提高了__八倍__！
然后，上面的测试仅仅是小的 DEMO 级别的测试，V8 团队更关心的是 <a href="https://v8.dev/blog/real-world-performance" target="_blank" rel="noopener noreferrer">实际用户代码的优化效果<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
<img src="https://img.alicdn.com/tfs/TB1uqJlpAzoK1RjSZFlXXai4VXa-600-371.svg" alt="image | left">
上面是基于市场上流行的 HTTP 框架做的测试，这些框架大量使用了 promises 和 <code>async</code> 函数，这个表展示的是每秒请求数，所以跟之前的表不一样，这个是数值越大越好。从表可以看出，从 Node.js 7 (V8 v5.5) 到 Node.js 10 (V8 v6.8) 性能提升了不少。
性能提升取决于以下三个因素：</p> <ul><li><a href="https://v8.dev/docs/turbofan" target="_blank" rel="noopener noreferrer">TurboFan<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，新的优化编译器 🎉</li> <li><a href="https://v8.dev/blog/orinoco" target="_blank" rel="noopener noreferrer">Orinoco<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，新的垃圾回收器 🚛</li> <li>一个 Node.js 8 的 bug 导致 await 跳过了一些微 tick（microticks） 🐛
当我们在 <a href="https://medium.com/the-node-js-collection/node-js-8-3-0-is-now-available-shipping-with-the-ignition-turbofan-execution-pipeline-aa5875ad3367" target="_blank" rel="noopener noreferrer">Node.js 8<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里 <a href="https://v8.dev/blog/launching-ignition-and-turbofan" target="_blank" rel="noopener noreferrer">启用 TurboFan<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的后，性能得到了巨大的提升。
同时我们引入了一个新的垃圾回收器，叫作 Orinoco，它把垃圾回收从主线程中移走，因此对请求响应速度提升有很大帮助。
最后，Node.js 8 中引入了一个 bug 在某些时候会让 <code>await</code> 跳过一些微 tick，这反而让性能变好了。这个 bug 是因为无意中违反了规范导致的，但是却给了我们优化的一些思路。这里我们稍微解释下：</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> p<span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after:await'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'tick:a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
 <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'tick:b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码一开始创建了一个已经完成状态的 promise <code>p</code>，然后 <code>await</code> 出其结果，又同时链了两个 <code>then</code>，那最终的 <code>console.log</code> 打印的结果会是什么呢？
因为 <code>p</code> 是已完成的，你可能认为其会先打印 <code>'after:await'</code>，然后是剩下两个 <code>tick</code>, 事实上 Node.js 8 里的结果是：
<img src="https://img.alicdn.com/tfs/TB1H_FhpCzqK1RjSZPcXXbTepXa-959-445.svg" alt="image | left">
虽然以上结果符合预期，但是却不符合规范。Node.js 10 纠正了这个行为，会先执行 <code>then</code> 链里的，然后才是 async 函数。
<img src="https://img.alicdn.com/tfs/TB1OthqpAvoK1RjSZFNXXcxMVXa-959-445.svg" alt="image | left">
这个「正确的行为」看起来并不正常，甚至会让很多 JavaScript 开发者感到吃惊，还是有必要再详细解释下。在解释之前，我们先从一些基础开始。</p> <h3 id="任务（tasks）vs-微任务（microtasks）"><a href="#任务（tasks）vs-微任务（microtasks）" aria-hidden="true" class="header-anchor">#</a> 任务（tasks）vs. 微任务（microtasks）</h3> <p>从某层面上来说，JavaScript 里存在任务和微任务。任务处理 I/O 和计时器等事件，一次只处理一个。微任务是为了 <code>async</code>/<code>await</code> 和 promise 的延迟执行设计的，每次任务最后执行。在返回事件循环（event loop）前，微任务的队列会被清空。
<img src="https://img.alicdn.com/tfs/TB1IXhnpxTpK1RjSZFKXXa2wXXa-832-286.svg" alt="image | left">
可以通过 Jake Archibald 的 <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">tasks, microtasks, queues, and schedules in the browser<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 了解更多。Node.js 里任务模型与此非常类似。</p> <h3 id="async-函数"><a href="#async-函数" aria-hidden="true" class="header-anchor">#</a> async 函数</h3> <p>根据 MDN，async 函数是一个通过异步执行并隐式返回 promise 作为结果的函数。从开发者角度看，async 函数让异步代码看起来像同步代码。
一个最简单的 async 函数：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">computeAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数执行后会返回一个 promise，你可以像使用其它 promise 一样用其返回的值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">computeAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → Promise</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// prints 42 on the next turn</span>
</code></pre></div><p>你只能在下一个微任务执行后才能得到 promise <code>p</code> 返回的值，换句话说，上面的代码语义上等价于使用 <code>Promise.resolve</code> 得到的结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">computeAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>async 函数真正强大的地方来源于 <code>await</code> 表达式，它可以让一个函数执行暂停直到一个 promise 已接受（resolved），然后等到已完成（fulfilled）后恢复执行。已完成的 promise 会作为 <code>await</code> 的值。这里的例子会解释这个行为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fetchStatus</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> response<span class="token punctuation">.</span>status<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>fetchStatus</code> 在遇到 <code>await</code> 时会暂停，当 <code>fetch</code> 这个 promise 已完成后会恢复执行，这跟直接链式处理 <code>fetch</code> 返回的 promise 某种程度上等价。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fetchStatus</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>链式处理函数里包含了之前跟在 <code>await</code> 后面的代码。
正常来说你应该在 <code>await</code> 后面放一个 <code>Promise</code>，不过其实后面可以跟任意 JavaScript 的值，如果跟的不是 promise，会被制转为 promise，所以 <code>await 42</code> 效果如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> v <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → Promise</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// prints `42` eventually</span>
</code></pre></div><p>更有趣的是，<code>await</code> 后可以跟任何 <a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">“thenable”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，例如任何含有 <code>then</code> 方法的对象，就算不是 promise 都可以。因此你可以实现一个有意思的 类来记录执行时间的消耗：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Sleep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> startTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">,</span>
               <span class="token keyword">this</span><span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> actualTime <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>actualTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一起来看看 V8 <a href="https://tc39.github.io/ecma262/#await" target="_blank" rel="noopener noreferrer">规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里是如何处理 <code>await</code> 的。下面是很简单的 async 函数 <code>foo</code>：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> w <span class="token operator">=</span> <span class="token keyword">await</span> v<span class="token punctuation">;</span>
  <span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行时，它把参数 <code>v</code> 封装成一个 promise，然后会暂停直到 promise 完成，然后 <code>w</code> 赋值为已完成的 promise，最后 async 返回了这个值。</p> <h3 id="神秘的-await"><a href="#神秘的-await" aria-hidden="true" class="header-anchor">#</a> 神秘的 <code>await</code></h3> <p>首先，V8 会把这个函数标记为可恢复的，意味着执行可以被暂停并恢复（从 <code>await</code> 角度看是这样的）。然后，会创建一个所谓的 <code>implicit_promise</code>（用于把 async 函数里产生的值转为 promise）。
<img src="https://img.alicdn.com/tfs/TB1knFmpCzqK1RjSZFLXXcn2XXa-960-469.svg" alt="image | left">
然后是有意思的东西来了：真正的 <code>await</code>。首先，跟在 <code>await</code> 后面的值被转为 promise。然后，处理函数会绑定这个 promise 用于在 promise 完成后恢复主函数，此时 async 函数被暂停了，返回 <code>implicit_promise</code> 给调用者。一旦 <code>promise</code> 完成了，函数会恢复并拿到从 <code>promise</code> 得到值 <code>w</code>，最后，<code>implicit_promise</code> 会用 <code>w</code> 标记为已接受。
简单说，<code>await v</code> 初始化步骤有以下组成：</p> <ol><li>把 <code>v</code> 转成一个 promise（跟在 <code>await</code> 后面的）。</li> <li>绑定处理函数用于后期恢复。</li> <li>暂停 async 函数并返回 <code>implicit_promise</code> 给掉用者。
我们一步步来看，假设 <code>await</code> 后是一个 promise，且最终已完成状态的值是 <code>42</code>。然后，引擎会创建一个新的 <code>promise</code> 并且把 <code>await</code> 后的值作为 resolve 的值。借助标准里的 <a href="https://tc39.github.io/ecma262/#sec-promiseresolvethenablejob" target="_blank" rel="noopener noreferrer">PromiseResolveThenableJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这些 promise 会被放到下个周期执行。
<img src="https://img.alicdn.com/tfs/TB1RBXqppzqK1RjSZFCXXbbxVXa-813-542.svg" alt="image | left">
然后，引擎创建了另一个叫做 <code>throwaway</code> 的 promise。之所以叫这个名字，因为没有其它东西链过它，仅仅是引擎内部用的。<code>throwaway</code> promise 会链到含有恢复处理函数的 <code>promise</code> 上。这里 <code>performPromiseThen</code> 操作其实内部就是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener noreferrer">Promise.prototype.then()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。最终，该 async 函数会暂停，并把控制权交给调用者。
<img src="https://img.alicdn.com/tfs/TB1UzXqpsbpK1RjSZFyXXX_qFXa-813-542.svg" alt="image | left">
调用者会继续执行，最终调用栈会清空，然后引擎会开始执行微任务：运行之前已准备就绪的 <a href="https://tc39.github.io/ecma262/#sec-promiseresolvethenablejob" target="_blank" rel="noopener noreferrer">PromiseResolveThenableJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，首先是一个 <a href="https://tc39.github.io/ecma262/#sec-promisereactionjob" target="_blank" rel="noopener noreferrer">PromiseReactionJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它的工作仅仅是在传递给 <code>await</code> 的值上封装一层 <code>promise</code>。然后，引擎回到微任务队列，因为在回到事件循环之前微任务队列必须要清空。
<img src="https://img.alicdn.com/tfs/TB1goXGpxjaK1RjSZFAXXbdLFXa-813-542.svg" alt="image | left">
然后是另一个 <a href="https://tc39.github.io/ecma262/#sec-promisereactionjob" target="_blank" rel="noopener noreferrer">PromiseReactionJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，等待我们正在 <code>await</code>（我们这里指的是 <code>42</code>）这个 <code>promise</code> 完成，然后把这个动作安排到 <code>throwaway</code> promise 里。引擎继续回到微任务队列，因为还有最后一个微任务。
<img src="https://img.alicdn.com/tfs/TB1.44wpAzoK1RjSZFlXXai4VXa-813-542.svg" alt="image | left">
现在这第二个 <a href="https://tc39.github.io/ecma262/#sec-promisereactionjob" target="_blank" rel="noopener noreferrer">PromiseReactionJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 把决定传达给 <code>throwaway</code> promise，并恢复 async 函数的执行，最后返回从 <code>await</code> 得到的 <code>42</code>。
<img src="https://img.alicdn.com/tfs/TB1WrXvpAvoK1RjSZFDXXXY3pXa-957-465.svg" alt="image | left">
总结下，对于每一个 <code>await</code> 引擎都会创建__两个额外__的 promise（即使右值已经是一个 promise），并且需要__至少三个__微任务。谁会想到一个简单的 <code>await</code> 竟然会有如此多冗余的运算？！
<img src="https://img.alicdn.com/tfs/TB1kLlrpr2pK1RjSZFsXXaNlXXa-451-214.svg" alt="image | left">
我们来看看到底是什么引起冗余。第一行的作用是封装一个 promise，第二行为了 resolve 封装后的 promose <code>await</code> 之后的值 <code>v</code>。这两行产生个冗余的 promise 和两个冗余的微任务。如果 <code>v</code> 已经是 promise 的话就很不划算了（大多时候确实也是如此）。在某些特殊场景 <code>await</code> 了 <code>42</code> 的话，那确实还是需要封装成 promise 的。
因此，这里可以使用 <a href="https://tc39.github.io/ecma262/#sec-promise-resolve" target="_blank" rel="noopener noreferrer">promiseResolve<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 操作来处理，只有必要的时候才会进行 promise 的封装：
<img src="https://img.alicdn.com/tfs/TB1bk0TpyLaK1RjSZFxXXamPFXa-949-376.svg" alt="image | left">
如果入参是 promise，则原封不动地返回，只封装必要的 promise。这个操作在值已经是 promose 的情况下可以省去一个额外的 promise 和两个微任务。此特性可以通过 <code>--harmony-await-optimization</code> 参数在 V8（从 v7.1 开始）中开启，同时我们 <a href="https://github.com/tc39/ecma262/pull/1250" target="_blank" rel="noopener noreferrer">向 ECMAScript 发起了一个提案<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，目测很快会合并。
下面是简化后的 <code>await</code> 执行过程：
<img src="https://img.alicdn.com/tfs/TB1mLNnpCzqK1RjSZPcXXbTepXa-792-545.svg" alt="image | left">
感谢神奇的 <a href="https://tc39.github.io/ecma262/#sec-promise-resolve" target="_blank" rel="noopener noreferrer">promiseResolve<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，现在我们只需要传 <code>v</code> 即可而不用关心它是什么。之后跟之前一样，引擎会创建一个 <code>throwaway</code> promise 并放到 <a href="https://tc39.github.io/ecma262/#sec-promisereactionjob" target="_blank" rel="noopener noreferrer">PromiseReactionJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里为了在下一个 tick 时恢复该 async 函数，它会先暂停函数，把自身返回给掉用者。
<img src="https://img.alicdn.com/tfs/TB1LjtqppYqK1RjSZLeXXbXppXa-648-548.svg" alt="image | left">
当最后所有执行完毕，引擎会跑微任务队列，会执行 <a href="https://tc39.github.io/ecma262/#sec-promisereactionjob" target="_blank" rel="noopener noreferrer">PromiseReactionJob<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。这个任务会传递 <code>promise</code> 结果给 <code>throwaway</code>，并且恢复 async 函数，从 <code>await</code> 拿到 <code>42</code>。
<img src="https://img.alicdn.com/tfs/TB11X4rpBLoK1RjSZFuXXXn0XXa-955-383.svg" alt="image | left">
尽管是内部使用，引擎创建 <code>throwaway</code> promise 可能还是会让人觉得哪里不对。事实证明，<code>throwaway</code> promise 仅仅是为了满足规范里 <code>performPromiseThen</code> 的需要。
<img src="https://img.alicdn.com/tfs/TB1P84xpsfpK1RjSZFOXXa6nFXa-936-198.svg" alt="image | left">
这是最近提议给 ECMAScript 的 <a href="https://github.com/tc39/ecma262/issues/694" target="_blank" rel="noopener noreferrer">变更<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，引擎大多数时候不再需要创建 <code>throwaway</code> 了。
<img src="https://img.alicdn.com/tfs/TB1wYFVpyLaK1RjSZFxXXamPFXa-939-355.svg" alt="image | left">
对比 <code>await</code> 在 Node.js 10 和优化后（应该会放到 Node.js 12 上）的表现：
<img src="https://img.alicdn.com/tfs/TB1bBhxprvpK1RjSZPiXXbmwXXa-600-371.svg" alt="image | left"> <strong><code>async</code></strong><strong>/</strong><strong><code>await</code></strong><strong> 性能超过了手写的 promise 代码</strong>。关键就是我们减少了 async 函数里一些不必要的开销，不仅仅是 V8 引擎，其它 JavaScript 引擎都通过这个 <a href="https://github.com/tc39/ecma262/pull/1250" target="_blank" rel="noopener noreferrer">补丁<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 实现了优化。</li></ol> <h2 id="开发体验优化"><a href="#开发体验优化" aria-hidden="true" class="header-anchor">#</a> 开发体验优化</h2> <p>除了性能，JavaScript 开发者也很关心问题定位和修复，这在异步代码里一直不是件容易的事。<a href="https://developers.google.com/web/tools/chrome-devtools" target="_blank" rel="noopener noreferrer">Chrome DevTools<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 现在支持了异步栈追踪：
<img src="https://img.alicdn.com/tfs/TB1gZlwpCzqK1RjSZFHXXb3CpXa-877-369.png" alt="image | left">
在本地开发时这是个很有用的特性，不过一旦应用部署了就没啥用了。调试时，你只能看到日志文件里的 <code>Error#stack</code> 信息，这些并不会包含任何异步信息。
最近我们搞的 <a href="https://bit.ly/v8-zero-cost-async-stack-traces" target="_blank" rel="noopener noreferrer">零成本异步栈追踪<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 使得 <code>Error#stack</code> 包含了 async 函数的调用信息。「零成本」听起来很让人兴奋，对吧？当 Chrome DevTools 功能带来重大开销时，它如何才能实现零成本？举个例子，<code>foo</code> 里调用 <code>bar</code>，<code>bar</code> 在 await 一个 promise 后抛一个异常：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'BEEP BEEP'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码在 Node.js 8 或 Node.js 10 运行结果如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ node index.js
Error: BEEP BEEP
    at bar <span class="token punctuation">(</span>index.js:8:9<span class="token punctuation">)</span>
    at process._tickCallback <span class="token punctuation">(</span>internal/process/next_tick.js:68:7<span class="token punctuation">)</span>
    at Function.Module.runMain <span class="token punctuation">(</span>internal/modules/cjs/loader.js:745:11<span class="token punctuation">)</span>
    at startup <span class="token punctuation">(</span>internal/bootstrap/node.js:266:19<span class="token punctuation">)</span>
    at bootstrapNodeJSCore <span class="token punctuation">(</span>internal/bootstrap/node.js:595:3<span class="token punctuation">)</span>
</code></pre></div><p>注意到，尽管是 <code>foo()</code> 里的调用抛的错，<code>foo</code> 本身却不在栈追踪信息里。如果应用是部署在云容器里，这会让开发者很难去定位问题。
有意思的是，引擎是知道 <code>bar</code> 结束后应该继续执行什么的：即 <code>foo</code> 函数里 <code>await</code> 后。恰好，这里也正是 <code>foo</code> 暂停的地方。引擎可以利用这些信息重建异步的栈追踪信息。有了以上优化，输出就会变成这样：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ node --async-stack-traces index.js
Error: BEEP BEEP
    at bar <span class="token punctuation">(</span>index.js:8:9<span class="token punctuation">)</span>
    at process._tickCallback <span class="token punctuation">(</span>internal/process/next_tick.js:68:7<span class="token punctuation">)</span>
    at Function.Module.runMain <span class="token punctuation">(</span>internal/modules/cjs/loader.js:745:11<span class="token punctuation">)</span>
    at startup <span class="token punctuation">(</span>internal/bootstrap/node.js:266:19<span class="token punctuation">)</span>
    at bootstrapNodeJSCore <span class="token punctuation">(</span>internal/bootstrap/node.js:595:3<span class="token punctuation">)</span>
    at async foo <span class="token punctuation">(</span>index.js:2:3<span class="token punctuation">)</span>
</code></pre></div><p>在栈追踪信息里，最上层的函数出现在第一个，之后是一些异步调用栈，再后面是 <code>foo</code> 里面 <code>bar</code> 上下文的栈信息。这个特性的启用可以通过 V8 的 <code>--async-stack-traces</code> 参数启用。
然而，如果你跟上面 Chrome DevTools 里的栈信息对比，你会发现栈追踪里异步部分缺失了 <code>foo</code> 的调用点信息。这里利用了 <code>await</code> 恢复和暂停位置是一样的特性，但 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener noreferrer">Promise#then()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch" target="_blank" rel="noopener noreferrer">Promise#catch()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 就不是这样的。可以看 Mathias Bynens 的文章 <a href="https://mathiasbynens.be/notes/async-stack-traces" target="_blank" rel="noopener noreferrer">await beats Promise#then()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 了解更多。</p> <h2 id="结论"><a href="#结论" aria-hidden="true" class="header-anchor">#</a> 结论</h2> <p>async 函数变快少不了以下两个优化：</p> <ul><li>移除了额外的两个微任务</li> <li>移除了 <code>throwaway</code> promise
除此之外，我们通过 <a href="https://bit.ly/v8-zero-cost-async-stack-traces" target="_blank" rel="noopener noreferrer">零成本异步栈追踪<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提升了 <code>await</code> 和 <code>Promise.all()</code> 开发调试体验。
我们还有些对 JavaScript 开发者友好的性能建议：
多使用 <code>async</code> 和 <code>await</code> 而不是手写 promise 代码，多使用 JavaScript 引擎提供的 promise 而不是自己去实现。</li></ul> <blockquote><p>文章可随意转载，但请保留此 <a href="https://www.yuque.com/es2049/blog" target="_blank" rel="noopener noreferrer">原文链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
非常欢迎有激情的你加入 <a href="https://es2049.studio/" target="_blank" rel="noopener noreferrer">ES2049 Studio<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，简历请发送至 caijun.hcj(at)<a href="http://alibaba-inc.com" target="_blank" rel="noopener noreferrer">alibaba-inc.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p></blockquote></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pixijs-101.html" class="prev">
          PixiJS 101
        </a></span> <span class="next"><a href="/prototype-review.html">
          Prototype Review
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.f42c0b44.js" defer></script><script src="/assets/js/31.bc58c029.js" defer></script>
  </body>
</html>
