(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{199:function(a,t,r){"use strict";r.r(t);var e=r(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"front-end-interview"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#front-end-interview","aria-hidden":"true"}},[a._v("#")]),a._v(" Front-End Interview")]),a._v(" "),r("h1",{attrs:{id:"prototype-multiply"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#prototype-multiply","aria-hidden":"true"}},[a._v("#")]),a._v(" Prototype, multiply")]),a._v(" "),r("p",[a._v("让下面的代码运行")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("const a = [ 1, 2, 3, 4, 5]\na.multiply();\nconsole.log(a) // 1, 2, 3, 4, 5, 1, 4, 9, 16, 25\n")])])]),r("p",[a._v("Solution:")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("Array.prototype.multiply = function() {\n    return this.concat(this.map(i => i*i))\n}\n")])])]),r("h1",{attrs:{id:"ieee754"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ieee754","aria-hidden":"true"}},[a._v("#")]),a._v(" IEEE754")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("0.2 + 0.1 === 0.3\n")])])]),r("p",[a._v("因为0.2+0.1丢失精度，结果是0.3000000...01.")]),a._v(" "),r("h1",{attrs:{id:"数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),r("p",[a._v("两种类型：主要类型和引用类型\nundefined, null, string, number, Symbol\nobject")]),a._v(" "),r("h1",{attrs:{id:"异步代码问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步代码问题","aria-hidden":"true"}},[a._v("#")]),a._v(" 异步代码问题")]),a._v(" "),r("p",[a._v("回调写法：XHR，或者是JQuery.ajax。\nPromise写法：fetch，没什么难度，返回值修改\nObservables：应该是Rx.fromfetch然后声明好结果\ngenerator：定义function*，依次返回答案\nasync-await：普通写法，没什么难度")]),a._v(" "),r("h1",{attrs:{id:"简单的数据绑定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单的数据绑定","aria-hidden":"true"}},[a._v("#")]),a._v(" 简单的数据绑定")]),a._v(" "),r("p",[a._v("两种写法，ES Proxy 或者是Object.defineProperty，然后如果有内部操作，劫持所有函数（Vue Augmentation）")]),a._v(" "),r("h1",{attrs:{id:"javascript并发模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#javascript并发模型","aria-hidden":"true"}},[a._v("#")]),a._v(" JavaScript并发模型")]),a._v(" "),r("p",[a._v("Event-loop，Web Worker两种。Node内部是libuv提供的事件循环。\n又有microtask和macrotask之分。\n栈和堆。")]),a._v(" "),r("h1",{attrs:{id:"new关键字"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#new关键字","aria-hidden":"true"}},[a._v("#")]),a._v(" new关键字")]),a._v(" "),r("p",[a._v("执行以下构造函数，原型链\n[[Construct]]和[[Call]]\nhttps://www.w3.org/html/ig/zh/wiki/ES5/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89")]),a._v(" "),r("h1",{attrs:{id:"四种函数调用的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四种函数调用的方式","aria-hidden":"true"}},[a._v("#")]),a._v(" 四种函数调用的方式")]),a._v(" "),r("p",[a._v("直函数调用、方法、call、apply")]),a._v(" "),r("blockquote",[r("p",[a._v("个人觉得这道题不好")])]),a._v(" "),r("h1",{attrs:{id:"es2018提案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#es2018提案","aria-hidden":"true"}},[a._v("#")]),a._v(" ES2018提案")]),a._v(" "),r("p",[a._v("BigInt，管道，private，for-async-of")]),a._v(" "),r("h1",{attrs:{id:"iterator和iterable"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#iterator和iterable","aria-hidden":"true"}},[a._v("#")]),a._v(" Iterator和Iterable")]),a._v(" "),r("p",[a._v("我只知道Array是Iterable的，用于for-of。")]),a._v(" "),r("h1",{attrs:{id:"类为什么是反模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类为什么是反模式","aria-hidden":"true"}},[a._v("#")]),a._v(" 类为什么是反模式")]),a._v(" "),r("p",[a._v("繁琐的继承、重新声明的构造函数、相等运算符的复杂性、Instanceof运算符的实效情况\n多重继承的防止、难以维护的原型链、重载和重写")]),a._v(" "),r("h1",{attrs:{id:"json-序列化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#json-序列化","aria-hidden":"true"}},[a._v("#")]),a._v(" JSON 序列化")]),a._v(" "),r("p",[a._v("Symbol不会被序列化")]),a._v(" "),r("h1",{attrs:{id:"typed-array"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#typed-array","aria-hidden":"true"}},[a._v("#")]),a._v(" Typed Array")]),a._v(" "),r("p",[a._v("实现不同，V8的内置方法可以更快优化（Torque）")]),a._v(" "),r("h1",{attrs:{id:"默认参数？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#默认参数？","aria-hidden":"true"}},[a._v("#")]),a._v(" 默认参数？")]),a._v(" "),r("p",[a._v("是不是用||做啊。。。不是很懂")]),a._v(" "),r("h1",{attrs:{id:"尾递归优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#尾递归优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 尾递归优化")]),a._v(" "),r("p",[a._v("就是把递归重写成循环的\n2018年还没有。")]),a._v(" "),r("h1",{attrs:{id:"单向数据流和双向绑定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流和双向绑定","aria-hidden":"true"}},[a._v("#")]),a._v(" 单向数据流和双向绑定")]),a._v(" "),r("p",[a._v("DirtyCheck， Zone.js，Vue defineProperty\nSetState，on...，Event/Emit")]),a._v(" "),r("h1",{attrs:{id:"单向数据流的应用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流的应用","aria-hidden":"true"}},[a._v("#")]),a._v(" 单向数据流的应用")]),a._v(" "),r("p",[a._v("那肯定是数据表格，简单的数据显示等等\n可以进行细粒度的优化，就是指shallow-compare然后按需更新这样。\n按需更新就可以走DocumentFragment然后replace node。")]),a._v(" "),r("h1",{attrs:{id:"mvc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mvc","aria-hidden":"true"}},[a._v("#")]),a._v(" MVC")]),a._v(" "),r("p",[a._v("SmallTalk")]),a._v(" "),r("h1",{attrs:{id:"函数式编程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数式编程")]),a._v(" "),r("p",[a._v("科里化（返回函数的函数，但是是链式的那种）\n高阶函数\n副作用\n记录类型 （不懂）")]),a._v(" "),r("h1",{attrs:{id:"函数式和反应式的关系"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数式和反应式的关系","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数式和反应式的关系")]),a._v(" "),r("p",[a._v("???没有什么关系好吧！完全看自己的实现，有时候全部函数式也很难受的，全部都要重新包装。")]),a._v(" "),r("h1",{attrs:{id:"immutable"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#immutable","aria-hidden":"true"}},[a._v("#")]),a._v(" Immutable")]),a._v(" "),r("p",[a._v("性能影响是内存不好管理，复制等等\n优势在于防止突变（mutations），不需要劫持，可以按需更新，为反应式做准备\n线程安全，全体原子化（有鸡巴用）")]),a._v(" "),r("h1",{attrs:{id:"大型项目，静态类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#大型项目，静态类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 大型项目，静态类型")]),a._v(" "),r("p",[a._v("Typescript。编译时\nFlow，运行时\n和其他语言的区别在于完全可擦除。")]),a._v(" "),r("p",[a._v("类型系统...不知道？\n类型推断就是根据已有的类型推断更多的类型。\nJS的类型本质就是...都是字典\n弱类型静态的是C++\n强类型动态的是Python")]),a._v(" "),r("h1",{attrs:{id:"模块系统"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块系统","aria-hidden":"true"}},[a._v("#")]),a._v(" 模块系统")]),a._v(" "),r("p",[a._v("AMD, CMD, UMD, RequireJS, CommonJS, ES模块\nWebpack")]),a._v(" "),r("h1",{attrs:{id:"http2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#http2","aria-hidden":"true"}},[a._v("#")]),a._v(" HTTP2")]),a._v(" "),r("p",[a._v("多路复用，头部压缩，全体二进制")]),a._v(" "),r("h1",{attrs:{id:"fetch的改进"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fetch的改进","aria-hidden":"true"}},[a._v("#")]),a._v(" Fetch的改进")]),a._v(" "),r("p",[a._v("好看的API，Promise based, 统一标准")]),a._v(" "),r("h1",{attrs:{id:"拉和推的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#拉和推的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" 拉和推的区别")]),a._v(" "),r("p",[a._v("RxJS说说，大家都懂。")]),a._v(" "),r("h1",{attrs:{id:"promise的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise的问题","aria-hidden":"true"}},[a._v("#")]),a._v(" Promise的问题")]),a._v(" "),r("p",[a._v("求值问题，撤销问题(cancellable)")]),a._v(" "),r("h1",{attrs:{id:"doctype"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#doctype","aria-hidden":"true"}},[a._v("#")]),a._v(" Doctype")]),a._v(" "),r("p",[a._v("怪异盒模型")]),a._v(" "),r("h1",{attrs:{id:"dom和bom的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dom和bom的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" DOM和BOM的区别")]),a._v(" "),r("p",[a._v("document和navigator？的区别，")]),a._v(" "),r("h1",{attrs:{id:"事件处理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 事件处理")]),a._v(" "),r("p",[a._v("冒泡、截取")]),a._v(" "),r("h1",{attrs:{id:"上传文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#上传文件","aria-hidden":"true"}},[a._v("#")]),a._v(" 上传文件")]),a._v(" "),r("p",[a._v("multipart、xhr2、FileAPI、Fetch（难用）")]),a._v(" "),r("h1",{attrs:{id:"重流重绘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重流重绘","aria-hidden":"true"}},[a._v("#")]),a._v(" 重流重绘")]),a._v(" "),r("p",[a._v("重流是重新排版\n重绘是局部的渲染 rasterize")]),a._v(" "),r("h1",{attrs:{id:"css选择性特异性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css选择性特异性","aria-hidden":"true"}},[a._v("#")]),a._v(" CSS选择性特异性")]),a._v(" "),r("p",[a._v("背一下各种优先级？")]),a._v(" "),r("h1",{attrs:{id:"css像素和物理像素的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css像素和物理像素的区别","aria-hidden":"true"}},[a._v("#")]),a._v(" CSS像素和物理像素的区别")]),a._v(" "),r("h1",{attrs:{id:"切片算法？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#切片算法？","aria-hidden":"true"}},[a._v("#")]),a._v(" 切片算法？")]),a._v(" "),r("p",[a._v("section")]),a._v(" "),r("h1",{attrs:{id:"flexbox-css-grid"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flexbox-css-grid","aria-hidden":"true"}},[a._v("#")]),a._v(" FlexBox/CSS Grid")]),a._v(" "),r("p",[a._v("很难聊")]),a._v(" "),r("h1",{attrs:{id:"css动画、过渡"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css动画、过渡","aria-hidden":"true"}},[a._v("#")]),a._v(" CSS动画、过渡")]),a._v(" "),r("p",[a._v("没什么难度")]),a._v(" "),r("h1",{attrs:{id:"css代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#css代码","aria-hidden":"true"}},[a._v("#")]),a._v(" CSS代码")]),a._v(" "),r("p",[a._v("魔术数（你能避免？）\nen/rem（偶尔可以用的）\n媒体查询（SCSS）\n滥用ID、类别（OOCSS）\nID会注册全局对象")]),a._v(" "),r("h1",{attrs:{id:"触摸事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触摸事件","aria-hidden":"true"}},[a._v("#")]),a._v(" 触摸事件")]),a._v(" "),r("p",[a._v("touchstart, touchend")]),a._v(" "),r("h1",{attrs:{id:"async，defer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async，defer","aria-hidden":"true"}},[a._v("#")]),a._v(" async，defer")]),a._v(" "),r("p",[a._v("阻塞不阻塞？同步不同步？")])])}],!1,null,null,null);t.default=s.exports}}]);