(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{187:function(e,r,s){"use strict";s.r(r);var t=s(0),o=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("div",{staticClass:"content"},[s("h1",{attrs:{id:"node-reverse-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-reverse-proxy","aria-hidden":"true"}},[e._v("#")]),e._v(" Node Reverse Proxy")]),e._v(" "),s("p",[e._v("这几天做GazeLabel的时候，遇到了CORS的跨域问题，主要情况是api-faceplusplus作为一个公开使用的API，居然不返回ACAO头，这样preflight就凉了...所以，面对这种素质较差的API提供商，我们选择用反代的形式解决这个问题。")]),e._v(" "),s("p",[e._v("由于是Nuxt的项目，所以本文以Node为主。当然为了更好的性能，Nginx也是可以反代的，还有一些类似与HAProxy的代理也可以使用。")]),e._v(" "),s("p",[e._v("首先，node内建的"),s("code",[e._v("request")]),e._v("包肯定是首选。因为它不仅不需要额外的依赖，更好的是它可以无损把接收到的信息pipe回去。但是，express项目中，没有自带"),s("code",[e._v("body-parser")]),e._v("，所以如果是需要req.body的处理，建议先安装body-parser再考虑处理后续的请求。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\napp.post('/api/method', (req, res) => {\n  req.pipe(request.post(someUrl, { json: true, body: req.body }), { end: false }).pipe(res);\n}\n\n")])])]),s("p",[e._v("这样，通过直接把请求pipe到request里面，然后再把结果pipe出来，效果非常好。")]),e._v(" "),s("p",[e._v("有个坑就是如果不确定请求的来源的METHOD，似乎不是很方便去把对应的请求方式pipe到request的特定方式下，只能通过获取"),s("code",[e._v("req.method")]),e._v("或者req.url去判断并在request的"),s("code",[e._v("option")]),e._v("对象里面带上"),s("code",[e._v("method: 'GET'")]),e._v("。")]),e._v(" "),s("p",[e._v("另外一种方式是通过一个叫做"),s("code",[e._v("node-http-proxy")]),e._v("的包，这个包可以很方便的代理所有某url下的请求。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\nconst express = require('express');\nconst vhost = require('vhost');\nconst compression = require('compression');\nconst httpProxy = require('http-proxy');\nconst history = require('connect-history-api-fallback');\nconst app = express();\napp.use(compression());\napp.all('/api/*', (req, res) => {\n  console.log(`reverse proxy REDIRECTED ${req.url} to port 5000`);\n  try {\n    apiProxy.web(req, res, { target: 'http://localhost:5000' });\n  } catch (e) {\n    console.log('proxy failed...Ignoring and continue');\n  }\n});\n\n")])])]),s("p",[e._v("还有一种方式是"),s("code",[e._v("CORS-anywhere")]),e._v("插件，但是这个插件似乎不太好控制访问的连接，感觉带来了很多不安全性，不是非常推荐。但是这个插件可以让某个url指向任意地址并带上CORS头部，感觉还是很炫酷的。似乎POST和GET都可以。")]),e._v(" "),s("p",[e._v("最后，如果是"),s("code",[e._v("axios")]),e._v("的终极粉丝，也可以使用axios返回代理的结果，其实axios的API还是非常美好的，但是就是不支持直接pipe express的req请求，用起来就没有request那么方便了。")]),e._v(" "),s("p",[e._v("最后说一点题外话，"),s("code",[e._v("body-parser")]),e._v("这个包如果在请求体积太大的时候会抛出"),s("code",[e._v("Entity too large")]),e._v("的错误，解决方案是在参数里面带上"),s("code",[e._v('limit: "50mb"')]),e._v("放宽类似的限制，就可以了。")])])}],!1,null,null,null);r.default=o.exports}}]);