(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{186:function(e,t,a){"use strict";a.r(t);var s=a(0),o=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"nodejs-data-persistence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-data-persistence","aria-hidden":"true"}},[e._v("#")]),e._v(" NodeJS Data Persistence")]),e._v(" "),a("p",[e._v("对于Node端的数据持久化，常见的做法是使用一些传统的SQL/NoSQL的驱动，然后进行数据交换。这种方法是比较高效的，而且对于高并发场景来说，这是一个很不错的解决方案。")]),e._v(" "),a("p",[e._v("如果不想使用传统数据驱动，包括但不限于添加额外非JS依赖，移动开发，多端兼容等等，可以考虑使用纯JS的数据库实现。")]),e._v(" "),a("p",[e._v("纯JS的数据持久化可以分为如下几种：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("文件型数据库(LowDB)，JSON序列化等。")])]),e._v(" "),a("li",[a("p",[e._v("内存型数据库(Map，Array）配合Lodash等。（这个真的持久吗）")])]),e._v(" "),a("li",[a("p",[e._v("存储API型数据库（IndexedDB，LocalStorage，SessionStorage）等。")])]),e._v(" "),a("li",[a("p",[e._v("服务器请求型（Cookie）。")])]),e._v(" "),a("li",[a("p",[e._v("混合型解决方案（NeDB，LocalForage等）。")])])]),e._v(" "),a("p",[e._v("以上的方案在不同情况下均有应用，他们分别有自己的局限性，比如文件型数据库需要写入权限、同步问题需要FileSync，内存型数据库并不持久，存储API型数据库有大小限制，请求型数据库有大小限制且带来额外贷款压力等。")]),e._v(" "),a("p",[e._v("还有一些时候，我们不希望引入过多的依赖和开发依赖，这个时候我们需要尽可能的减少依赖包的引入。但是数据库的API普遍不友好，需要做很多边缘级的优化，这个时候如果某些库可以Standalone跑，也是可以使用的。")]),e._v(" "),a("p",[e._v("References:")]),e._v(" "),a("p",[e._v("https://github.com/louischatriot/nedb")]),e._v(" "),a("p",[e._v("https://localforage.github.io/localForage/")])])}],!1,null,null,null);t.default=o.exports}}]);