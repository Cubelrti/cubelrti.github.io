(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{195:function(e,t,r){"use strict";r.r(t);var a=r(0),n=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"intersection-observer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#intersection-observer","aria-hidden":"true"}},[this._v("#")]),this._v(" Intersection Observer")]),this._v(" "),t("p",[this._v("The Intersection Observer API is relatively new. It makes it simple to detect when an element enters the viewport and take an action when it does. In the previous method, we had to bind events, keep performance in mind and implement a way to calculate if the element was in the viewport or not. The Intersection Observer API removes all that overhead by avoiding the math and delivering great performance out of the box.\nBelow is an example using the API to lazy load images. We attach the observer on all the images to be lazy loaded. Once the API detects that the element has entered the viewport, using the isIntersecting property, we pick the URL from the data-srcattribute and move it to the src attribute for the browser to trigger the image load. Once this is done, we remove the lazy class from the image and also remove the observer from that image.")])])}],!1,null,null,null);t.default=n.exports}}]);