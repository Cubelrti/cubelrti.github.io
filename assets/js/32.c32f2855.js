(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{179:function(o,t,r){"use strict";r.r(t);var _=r(0),e=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var o=this,t=o.$createElement,r=o._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"prototype-review"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#prototype-review","aria-hidden":"true"}},[o._v("#")]),o._v(" Prototype Review")]),o._v(" "),r("h1",{attrs:{id:"经典的原型链与它的内部思想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#经典的原型链与它的内部思想","aria-hidden":"true"}},[o._v("#")]),o._v(" 经典的原型链与它的内部思想")]),o._v(" "),r("p",[o._v("可以见到上图中，分为三栏，分别是objects, functions 和 function prototypes。")]),o._v(" "),r("p",[o._v("也就是说，任何的Javascript函数，都拥有它的原型（prototype）。这个原型，是隐藏在实现内部的，也就是__proto__的具体含义。")]),o._v(" "),r("p",[o._v("首先，我们写出一个函数Foo()。Foo便在作用域中创建了一个Foo的指针，这个指针指向函数Foo。")]),o._v(" "),r("p",[o._v("除此，Foo还创建了一个原型对象，叫做Foo.prototype。这个是所有使用Foo创建出来的对象所共享的原型对象。这个对象，拥有一个叫做constructor的指针，它指向了Foo函数。这个指针用来干什么？就是在我们使用Foo创建对象以后，可以用Foo.prototype.constructor来找到这个函数对象。")]),o._v(" "),r("p",[o._v("于是，我们使用Foo创建一个对象实例，叫做fooObj。fooObj拥有一个内部指针，虽然它已经可以被任何人访问了，也就是__proto__。我们可以发现，fooObj其实是一个干净的对象，它没有constructor。但是由于它有__proto__，那么由于JavaScript的向上查询，它会查询到Foo.__proto__的constructor，也就是Foo.prototype。这里，Foo.prototype有constructor，所以，便返回了Foo函数。")]),o._v(" "),r("p",[o._v("使用function name() {}创建的函数中，都有自己的__proto__，也就是Object.prototype。然后，Object."),r("strong",[o._v("proto")]),o._v("，是null。**这里需要注意，所有的函数，他的__proto__都是Function.prototype。**那么一共有三个指向Function.prototype的指针，分别是Foo."),r("strong",[o._v("proto")]),o._v("，Function.__proto__以及Object."),r("strong",[o._v("proto")]),o._v("。可以理解，所有的Object都是由Function创建的，包括Object函数。"),r("strong",[o._v("所有的原型对象，除了Object自己，__proto__都是Object.prototype。")])])])}],!1,null,null,null);t.default=e.exports}}]);